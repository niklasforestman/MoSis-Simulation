Index: simulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nProgram: Coronavirus Simulation\nOrigin Author: Nathan Verghis\n\nNew Program Name\nAuthors: KT MoSi (Albrecht Pohl, Niklas Waldmann)\n\n\n\"\"\"\n\n#   === INIT ===\n\nimport sys\nimport pygame\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom pygame.locals import *\nfrom random import randint\nimport time\nimport numpy as np\nscale = 700 #Standardeinstellung: 700 #Skalierung\nup = 1 ##Standardeinstellung: 1  #Bewegungsgeschwindigkeit der Personen\ndev_mode = True\nresult = True\n#Szenario_1: Isolierung aller ab einer bestimmten Infektionszahl\n#Szenario_2: Isolierung von Personen mit Symptomen\nevents_enabled = 0 # Bei bestimmten Punkten reguliert sich das System probehalber selbst.\nisolation_enabled = False #Parameter Definition für die Selbstregulierung\ntests_enabled = False\n\nif scale > 600:\n    popsize = scale + 600\nelse:\n    popsize = scale\n\nend_dist = pd.DataFrame(columns=['Age','Alive'],index=range(popsize))\n\n\n\nif dev_mode == True:\n\n    isolation = 0 #Standardeinstellung: 0\n    infected = 2 #Standardeinstellung: 2\n    infection_chance = 40#Standardeinstellung: 60\n    recovery = 12 #Standardeinstellung:8\n    heavy_case = 10#Standardeinstellung: 2\n    incubation_time = 28 #Standardeinstellung: 20\n    superspreader = 50 #Standardeinstellung: 10\n    testrate = 100\n\nelse:\n    # Game Settings\n    print(\"Please enter an isolation constant (0-100):\")\n    isolation = float(input())\n\n    print(\"Please enter an starting infected population (0-100):\")\n    infected = int(input())\n\n    print(\"Please enter an infection chance (0-100):\")\n    infection_chance = int(input())\n\n    #print(\"Please enter a mortality rate (0-100):\")\n    #mortality = int(input())\n    #über Statistik eingeführt\n\n    print(\"Please enter a recovery rate (0-100):\")\n    recovery = int(input())\n\n    print(\"Please enter a chance of a heavy case (0-100):\")\n    heavy_case = int(input())\n\n\n#mortality = 2\n#recovery = 15\n\npygame.init()\npygame.display.set_caption(\"Coronavirus Infection Simulation\")\nsize = width, height = scale, scale\nspeed = [25, 0]\nwhite = 255, 255, 255\nday_counter = 0\ncount = 0\npop_dist = [[0,18.4],[20,18.4+24.6],[40,18.4+24.6+28.8],[60,18.4+24.6+28.8+21.7],[80,18.4+24.6+28.8+21.7+6.5]]\n#Altersverteilung in Deutschland nach (https://www.destatis.de/DE/Themen/Gesellschaft-Umwelt/Bevoelkerung/Bevoelkerungsstand/Tabellen/liste-altersgruppen.html)\n#erster Eintrag: Untergrenze Alter, zweiter Eintrag: kumulierter Anteil an Bevölkerung\nmort_rate = [[0,(0+0.2)/2/10],[20,0.2/10],[40,(0.4+1.3)/2/10],[60,(3.6+8)/2/10],[80,14.8/10]]#\n#Sterblichkeitsrate über Alter nach (https://www.dw.com/de/coronavirus-endlich-umfassende-daten-aus-china/a-52421582)\n#Quelle: Chinese Center for Disease Control and Prevention\n#erster Eintrag: Untergrenze Alter, zweiter Eintrag: Sterblichkeitsrate angepasst an Altersverteilung\n\n# === DEF ===\n\n# Creating People object\nclass Person:\n    \"\"\"BEschreibt eine einzelne Person in der Simulation. Die Person hat verschiedene Attribute, welche unten aufgefhrt sind. Eine Person kann über die\n    Funktion Contact mit anderen Personen interagieren\"\"\"\n    def __init__(self, isolated, sick,immune,heavy,infected,superspread):\n        self.counter = 0\n        self.alive = True\n        self.immune = False\n        self.isolated = isolated\n        self.infected = infected\n        self.sick = sick\n        self.heavy = heavy\n        self.age = 0\n        self.mortality = 0\n        self.finished = False #Mit Virus in kontakt gekommen. Wichtig für r0-Berechnung\n        self.dead =False\n        self.superspread = superspread\n        if not tests_enabled:\n            self.tested = True\n        else:\n            self.tested = False\n\n        if self.isolated:\n            self.speed = [0, 0]\n\n        if not tests_enabled:\n            if self.superspread:\n                self.speed = [randint(-100, 100) * 0.05, randint(-100, 100) * 0.05]\n            else:\n                self.speed = [randint(-100, 100) * 0.025, randint(-100, 100) * 0.025]\n            if sick:\n                self.image = pygame.image.load(\"red box 2.jpg\")\n            if immune:\n                self.image = pygame.image.load(\"green square 2.jpg\")\n            if infected:\n                self.image = pygame.image.load(\"rosa box.jpg\")\n            if superspread:\n                self.image = pygame.image.load(\"yellow box 2.jpg\")\n            else:\n                self.image = pygame.image.load(\"black box.jpg\")\n            self.ps = self.image.get_rect()\n            k=int(scale/10)\n            self.left = randint(1, k)\n            self.top = randint(1, k)\n            rand_age = randint(0,100)\n            for age_class in range(len(pop_dist)):\n                if rand_age < pop_dist[age_class][1]:\n                    self.age = pop_dist[age_class][0] + randint(0,20)\n                    break\n            for age_class in range(len(mort_rate)-1):\n                if self.age >= mort_rate[-1][0]:\n                    self.mortality = mort_rate[-1][1]\n                    break\n                elif self.age < mort_rate[age_class+1][0]:\n                    self.mortality =  mort_rate[age_class][1]\n                    break\n        elif tests_enabled:\n            if self.superspread:\n                self.speed = [randint(-100, 100) * 0.05, randint(-100, 100) * 0.05]\n            else:\n                self.speed = [randint(-100, 100) * 0.025, randint(-100, 100) * 0.025]\n            self.image = pygame.image.load(\"black box.jpg\")\n            self.ps = self.image.get_rect()\n            k=int(scale/10)\n            self.left = randint(1, k)\n            self.top = randint(1, k)\n            rand_age = randint(0,100)\n            for age_class in range(len(pop_dist)):\n                if rand_age < pop_dist[age_class][1]:\n                    self.age = pop_dist[age_class][0] + randint(0,20)\n                    break\n            for age_class in range(len(mort_rate)-1):\n                if self.age >= mort_rate[-1][0]:\n                    self.mortality = mort_rate[-1][1]\n                    break\n                elif self.age < mort_rate[age_class+1][0]:\n                    self.mortality =  mort_rate[age_class][1]\n                    break\n\n\n    def new_step(self):\n        \"\"\"Diese Funktion berechnet den nächsten Zeitschritt. Tests, Bewegung, Krankheitsentwicklung werden hier beschrieben und ausgewertet.\"\"\"\n\n        a = randint(-100,100) # generiert zwei Zufallszahlen, welche für die Wahrscheinlichkeitsrechnung benötigt werden\n        b = randint(-100,100)\n\n        #Testen der Personengruppen:\n        if tests_enabled:\n            if abs(a) < testrate and (self.infected or self.sick):\n                self.tested = True\n\n        #Berechnung der Geschwindigkeiten einer einzelnen Person für den nächsten Zweitschritt:\n        if self.isolated:\n            self.speed = [0, 0]\n\n        elif self.alive and self.superspread==0:\n            self.speed = [a * 0.04*up, b * 0.04*up]\n\n        #Entscheidung über den Status (Krankheitsverlauf) einezer einzelnen Person der Population:\n        if self.infected and abs(a) < incubation_time:\n                self.infected = False\n                self.sick = True\n                if not tests_enabled or (tests_enabled and self.tested):\n                    self.image = pygame.image.load(\"red box 2.jpg\")\n\n        #Beschreibt den Heilungsprozess\n        if self.sick or self.heavy:\n            if abs(b) < recovery:\n                self.finished = True\n                self.isolated = False\n                self.sick = False\n                self.heavy = False\n                self.immune = True\n                if not tests_enabled or (tests_enabled and self.tested):\n                    self.image = pygame.image.load(\"green square 2.jpg\")\n\n        if self.sick and abs(a) < heavy_case:\n            self.isolated = True #Person wird stationär aufgenommen --> Mobilität = 0\n            self.superspread = False\n            self.heavy = True\n            if not tests_enabled or (tests_enabled and self.tested):\n                    self.image = pygame.image.load(\"red box 2.jpg\")\n\n        if self.heavy and abs(a) < self.mortality:\n            self.finished = True\n            self.alive = False\n            self.heavy = False\n            self.immune = False\n            self.dead = True\n            self.sick = False\n            #self.immune = False\n            self.image = pygame.image.load(\"dark red 2.jpg\")\n\n        if not self.alive:\n            self.immune = False\n\n\n\n    def contact(self, other):\n        \"\"\" Dies ist eine Funktion, welche den Kontakt zweier Personen beschreibt und die Ansteckungsgefahr simuliert\"\"\"\n        if self.ps.colliderect(other.ps) and not self.immune and not other.immune and not self.isolated and not other.isolated and self.alive and other.alive:\n            \n            self.speed[0], self.speed[1] = self.speed[0] * -1, self.speed[1] * -1\n            other.speed[0], other.speed[1] = other.speed[0] * -1, other.speed[1] * -1\n            \n            if self.sick and not other.sick:\n                if infection_chance > randint(0,100): \n                    self.counter +=1 # Zählt die angesteckten Personen durch die Person selbst.\n                    other.infected = True \n                    if not tests_enabled or (tests_enabled and self.tested): #Personen, welche durch Infizierte angesteckt werden, werden wie bereits geteste behandelt\n                        other.image = pygame.image.load(\"rosa box.jpg\")\n                        \n            elif not self.sick and other.sick:\n                if infection_chance >  randint(0,100):\n                    self.infected = True\n                    if not tests_enabled or (tests_enabled and other.tested):\n                        self.image = pygame.image.load(\"rosa box.jpg\")\n\n            if self.infected and not other.sick:\n                if infection_chance > randint(0,100):\n                    self.counter +=1\n                    other.infected = True\n                    if not tests_enabled or (tests_enabled and self.tested):\n                        other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.infected:\n                if infection_chance >  randint(0,100):\n                    self.infected = True\n                    if not tests_enabled or (tests_enabled and other.tested):\n                        self.image = pygame.image.load(\"rosa box.jpg\")\n                        \n                        \n        if self.ps.colliderect(other.ps) and not self.immune and not other.immune and self.alive and other.alive:\n            \n            self.speed[0], self.speed[1] = self.speed[0] * -1, self.speed[1] * -1\n            other.speed[0], other.speed[1] = other.speed[0] * -1, other.speed[1] * -1\n            \n            if self.sick and not other.sick:\n                if infection_chance/2 > randint(0,100):\n                    self.counter +=1\n                    other.infected = True\n                    if not tests_enabled or (tests_enabled and self.tested):\n                        other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.sick:\n                if infection_chance/2 > randint(0,100):\n                    self.infected = True\n                    if not tests_enabled or (tests_enabled and other.tested):\n                        self.image = pygame.image.load(\"rosa box.jpg\")\n\n            if self.infected and not other.sick:\n                if infection_chance/2 > randint(0,100):\n                    self.counter +=1\n                    other.infected = True\n                    if not tests_enabled or (tests_enabled and self.tested):\n                        other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.infected:\n                if infection_chance/2 >  randint(0,100):\n                    self.infected = True\n                    if not tests_enabled or (tests_enabled and other.tested):\n                        self.image = pygame.image.load(\"rosa box.jpg\")\n\n\ndef sim_continue(pop):\n    \"\"\"Diese Funktion beschreibt die Endbedingung für das Programm\"\"\"\n    all_dead = all(not people.alive for people in pop)\n    all_healed = all(not people.sick and not people.infected for people in pop)\n    return not(all_dead or all_healed)\n\n\ndef statistics(pop):\n    \"\"\"Stellt eine Statistik zusammen, welche am Ende des Programms durchgeführt wird.\"\"\"\n    alive = 0\n    dead = 0\n    immune = 0\n\n    ppl_count = -1\n    for people in pop:\n        ppl_count += 1\n        end_dist['Age'][ppl_count] = people.age\n        if people.immune:\n            immune+=1\n        if people.alive:\n            alive += 1\n            end_dist['Alive'][ppl_count] = 1\n        else:\n            dead += 1\n            end_dist['Alive'][ppl_count] = 0\n\n    return alive, dead, immune, end_dist\n\n\n# === PROGRAM ===\n\nscreen = pygame.display.set_mode(size)\npopulation = []\n\n# Aufbauen der Population\nfor i in range(popsize):\n    is_isolated = False\n    is_infected = False\n    is_immune = False\n    is_heavy = False\n    is_superspread = False\n    temp = randint(1, popsize)\n    if temp < isolation: \n        is_isolated = True # Mit einer gewählten Wahrscheinlichkeit ist die Person isoliert.\n    if temp < infected:\n        is_infected = True # Mit einer gewählten Wahrscheinlichkeit ist die Person infiziert.\n    if temp < superspreader:\n        is_superspread = True  # Mit einer gewählten Wahrscheinlichkeit ist die Person superspreader.\n    new_person = Person(is_isolated, is_infected,is_immune,is_heavy,is_infected,is_superspread) #Erstellen eines Objekts Person mit den oben genannten Eigenschaften\n    end_dist['Age'][i] = new_person.age\n    new_person.ps = new_person.ps.move(new_person.left*10, new_person.top*10) # Setzen der Personen auf das Spielfeld\n    population.append(new_person)\n\n\n#Initialisierung der Arrays für die Speicherung der Ergebnisse der einzenen Zeitschritte\ndays = np.ones(100)\ndays[0] = 0\npeople_infected = np.zeros(1000)\ndarkfigure = np.zeros(1000)\npeople_immune = np.zeros(1000)\npeople_dead = np.zeros(1000)\npeople_alive = np.zeros(1000)\nr0_current = np.zeros(1000)\nr0_current_superspreader = np.zeros(1000)\npeople_infected[0] = infected/popsize\n# Creating the Simulation\nwhile sim_continue(population):\n    count += 1\n    if count == 12:\n        day_counter += 1\n\n    #Hilfsvariablen für die Berechnung\n    inf=0\n    inf_2 = 0\n    imm=0\n    dead=0\n    d=0\n    fin =0\n    d2 = 0\n    z2 = 0\n    tested = 0\n\n    #Durchzählen der Population auf bestimmte Eigenschaften\n    for people in population:\n        if people.infected ==True:\n            inf+=1\n        if (people.infected or people.sick or people.finished) and people.tested:\n            inf_2+=1\n        if people.sick == True:\n            inf+=1\n        if people.immune ==True:\n            imm +=1\n        if people.alive == False:\n            dead +=1\n        if people.finished:\n            fin +=1\n            d+= people.counter\n        if people.tested:\n            tested +=1\n\n    if fin>0:\n        r0_current[day_counter] = d/fin\n    else:\n        r0_current[day_counter] = 0\n\n    people_infected[day_counter]=inf/popsize\n    if inf_2==0:\n        darkfigure[day_counter] = 0\n    else:\n        darkfigure[day_counter] = (inf+fin)/inf_2\n    people_immune[day_counter]=imm/popsize\n    people_dead[day_counter]=dead/popsize\n    people_alive[day_counter]=1-dead/popsize\n\n    if count == 12:\n        print(\"Tag: \",day_counter,\".....\",\"Isolationsaufruf: \",isolation_enabled,\".....\",\"r0: \",r0_current[day_counter],\".....\",\"aktuell Infizierte: \",people_infected[day_counter],\".....\",\"Dunkelziffer: \",darkfigure[day_counter],\".....\",\"aktuell Immune: \",people_immune[day_counter],\".....\",\"aktuell Verstorbene: \",people_dead[day_counter])\n        count = 0\n\n    #Isolation ist während des Programms über die Pfeiltasten rechts und links steuerbar.\n    for event in pygame.event.get():\n        if event.type == KEYDOWN and event.key == K_RIGHT:\n            for people in population:\n                if randint(0,100)<60:  #Mit einer Wahrscheinlihckeit von 60% halten sich die Personen an die Regeln\n                    people.isolated = True\n        elif event.type == KEYDOWN and event.key == K_LEFT:\n            for people in population:\n                if not people.heavy or people.alive:\n                    people.isolated = False\n                    isolation_enabled = False\n                    #events_enabled = False #Stellt eigenständige Events aus\n     #Impfstoff sofort für alle Kranken verfügbar\n    for event in pygame.event.get():\n        if event.type == KEYDOWN and event.key == K_UP:\n            for people in population:\n                if people.sick or people.infected:\n                    people.sick = False\n                    people.infected = False\n                    people.immune = True\n                    self.image = pygame.image.load(\"green square 2.jpg\")\n\n\n\n    if events_enabled == 1:\n        if people_infected[day_counter] > 0.10 and not isolation_enabled:\n            for people in population:\n                if randint(0,100)<40:  #Mit einer Wahrscheinlihckeit von 40% halten sich die Personen an die Regeln\n                    people.isolated = True\n                isolation_enabled = True\n        elif people_infected[day_counter] < 0.05:\n            isolation_enabled = False\n            for people in population:\n                if not people.heavy or people.alive:\n                    people.isolated = False\n    if events_enabled == 2:\n        for people in population:\n            if people.sick:\n                people.isolated = True\n            elif people.immune:\n                people.isolated = False\n\n    screen.fill(white)\n    for person in population:\n        person.ps = person.ps.move(person.speed)\n        if person.ps.left < 0 or person.ps.right > width:\n            person.speed[0] = person.speed[0] * -1\n        if person.ps.top < 0 or person.ps.bottom > height:\n            person.speed[1] = person.speed[1] * -1\n        for friend in population:\n            if person is friend:\n                pass\n            else:\n                person.contact(friend)\n        if count == 0:\n            person.new_step()\n        screen.blit(person.image, person.ps)\n\n    pygame.display.flip()\n\n\n\nprint(\"Days til completion: \", day_counter)\n\nalive, dead, immune, end_dist = statistics(population)\n#stats = statistics(population)\nprint(\"Alive: \", alive)\nprint(\"Dead: \", dead)\nprint(\"Immune: \",immune)\n\n\nif result == True:\n    # === AUSWERTUNG ===\n\n    plt.ylabel('Aktuell Infizierte')\n\n    # Einen x-y-Plot erstellen:\n    plt.plot(people_infected, 'b-')\n    plt.plot(people_immune, 'g-')\n    plt.plot(people_dead, 'r-')\n    plt.plot(people_alive, 'y-')\n    plt.plot(r0_current, 'g-')\n\n    # Achsen-Bereiche manuell festlegen\n    # Syntax: plt.axis([xmin, xmax, ymin, ymax])\n    #plt.axis([0, 5, 0, 20])\n\n    # Ein gepunktetes Diagramm-Gitter einblenden:\n    plt.grid(True)\n\n    # Diagramm anzeigen:\n    plt.show()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- simulation.py	(revision 6daa0d3ab991518006ba69ef656480952abe1186)
+++ simulation.py	(date 1587485551586)
@@ -93,8 +93,9 @@
 
 # Creating People object
 class Person:
-    """BEschreibt eine einzelne Person in der Simulation. Die Person hat verschiedene Attribute, welche unten aufgefhrt sind. Eine Person kann über die
-    Funktion Contact mit anderen Personen interagieren"""
+    """(To DO ANPASSEN)A single person in the game. Has attributes of being sick, isolated, and
+    alive. Meant to interact with another member of its population to create
+    the simulation."""
     def __init__(self, isolated, sick,immune,heavy,infected,superspread):
         self.counter = 0
         self.alive = True
@@ -171,8 +172,13 @@
                     break
 
 
-    def new_step(self):
-        """Diese Funktion berechnet den nächsten Zeitschritt. Tests, Bewegung, Krankheitsentwicklung werden hier beschrieben und ausgewertet."""
+    def new_day(self):
+        """(To DO ANPASSEN)The change from day to day for a sick person.
+        They can either recover or die
+        If dead then they have no more impact on the population"""
+
+
+
 
         a = randint(-100,100) # generiert zwei Zufallszahlen, welche für die Wahrscheinlichkeitsrechnung benötigt werden
         b = randint(-100,100)
@@ -189,14 +195,18 @@
         elif self.alive and self.superspread==0:
             self.speed = [a * 0.04*up, b * 0.04*up]
 
+
+
         #Entscheidung über den Status (Krankheitsverlauf) einezer einzelnen Person der Population:
         if self.infected and abs(a) < incubation_time:
-                self.infected = False
+                self.infected = False #PRÜFEN
                 self.sick = True
+                #self.alive = True
                 if not tests_enabled or (tests_enabled and self.tested):
                     self.image = pygame.image.load("red box 2.jpg")
 
-        #Beschreibt den Heilungsprozess
+
+
         if self.sick or self.heavy:
             if abs(b) < recovery:
                 self.finished = True
@@ -204,17 +214,27 @@
                 self.sick = False
                 self.heavy = False
                 self.immune = True
+                #self.alive = True
+                #self.speed = [a * 0.05, b * 0.05] # Person nimmt wieder am Öffentlichen Leben teil
                 if not tests_enabled or (tests_enabled and self.tested):
                     self.image = pygame.image.load("green square 2.jpg")
 
+
         if self.sick and abs(a) < heavy_case:
             self.isolated = True #Person wird stationär aufgenommen --> Mobilität = 0
             self.superspread = False
+            #self.speed = [0, 0]
+            #self.alive = True
             self.heavy = True
+            #self.sick = True
             if not tests_enabled or (tests_enabled and self.tested):
                     self.image = pygame.image.load("red box 2.jpg")
 
+
         if self.heavy and abs(a) < self.mortality:
+            #self.isolated = True
+            #self.superspread = False
+            #self.speed = [0, 0]
             self.finished = True
             self.alive = False
             self.heavy = False
@@ -228,82 +248,117 @@
             self.immune = False
 
 
+        """" if self.heavy:
+            if abs(b) < recovery:
+                self.isolated = False
+                self.sick = False
+                self.heavy = False
+                self.immune = True
+                self.alive = True
+                self.speed = [a * 0.05, b * 0.05]
+                self.image = pygame.image.load("green square 2.jpg")"""
+
+
+
 
     def contact(self, other):
-        """ Dies ist eine Funktion, welche den Kontakt zweier Personen beschreibt und die Ansteckungsgefahr simuliert"""
+        """ (To DO ANPASSEN) The event that two people come in contact with each other.
+        Handles the case where the infection spreads
+        Also handles the change in direction as they part ways
+        Isolated people dont come into contact so people pass through them"""
         if self.ps.colliderect(other.ps) and not self.immune and not other.immune and not self.isolated and not other.isolated and self.alive and other.alive:
-            
-            self.speed[0], self.speed[1] = self.speed[0] * -1, self.speed[1] * -1
-            other.speed[0], other.speed[1] = other.speed[0] * -1, other.speed[1] * -1
-            
+            self.speed[0], self.speed[1] = \
+                self.speed[0] * -1, self.speed[1] * -1
+            other.speed[0], other.speed[1] = \
+                other.speed[0] * -1, other.speed[1] * -1
             if self.sick and not other.sick:
-                if infection_chance > randint(0,100): 
-                    self.counter +=1 # Zählt die angesteckten Personen durch die Person selbst.
-                    other.infected = True 
-                    if not tests_enabled or (tests_enabled and self.tested): #Personen, welche durch Infizierte angesteckt werden, werden wie bereits geteste behandelt
+                if infection_chance > randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
+                    self.counter +=1
+                    other.infected = True
+                    if not tests_enabled or (tests_enabled and self.tested):
                         other.image = pygame.image.load("rosa box.jpg")
-                        
+
+
             elif not self.sick and other.sick:
                 if infection_chance >  randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.infected = True
                     if not tests_enabled or (tests_enabled and other.tested):
                         self.image = pygame.image.load("rosa box.jpg")
 
             if self.infected and not other.sick:
                 if infection_chance > randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.counter +=1
                     other.infected = True
                     if not tests_enabled or (tests_enabled and self.tested):
                         other.image = pygame.image.load("rosa box.jpg")
             elif not self.sick and other.infected:
                 if infection_chance >  randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.infected = True
                     if not tests_enabled or (tests_enabled and other.tested):
                         self.image = pygame.image.load("rosa box.jpg")
-                        
-                        
-        if self.ps.colliderect(other.ps) and not self.immune and not other.immune and self.alive and other.alive:
-            
-            self.speed[0], self.speed[1] = self.speed[0] * -1, self.speed[1] * -1
-            other.speed[0], other.speed[1] = other.speed[0] * -1, other.speed[1] * -1
-            
+        if self.ps.colliderect(other.ps) and not self.immune and not other.immune and self.alive and other.alive: # and not self.isolated and not other.isolated:
+            self.speed[0], self.speed[1] = \
+                self.speed[0] * -1, self.speed[1] * -1
+            other.speed[0], other.speed[1] = \
+                other.speed[0] * -1, other.speed[1] * -1
             if self.sick and not other.sick:
                 if infection_chance/2 > randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.counter +=1
                     other.infected = True
                     if not tests_enabled or (tests_enabled and self.tested):
                         other.image = pygame.image.load("rosa box.jpg")
             elif not self.sick and other.sick:
                 if infection_chance/2 > randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.infected = True
                     if not tests_enabled or (tests_enabled and other.tested):
                         self.image = pygame.image.load("rosa box.jpg")
 
             if self.infected and not other.sick:
                 if infection_chance/2 > randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.counter +=1
                     other.infected = True
                     if not tests_enabled or (tests_enabled and self.tested):
                         other.image = pygame.image.load("rosa box.jpg")
             elif not self.sick and other.infected:
                 if infection_chance/2 >  randint(0,100):
+                    #self.finished = True # Person zählt bei r0-Berechnung
+                    #other.finished = True # Person zählt bei r0-Berechnung
                     self.infected = True
                     if not tests_enabled or (tests_enabled and other.tested):
                         self.image = pygame.image.load("rosa box.jpg")
 
 
 def sim_continue(pop):
-    """Diese Funktion beschreibt die Endbedingung für das Programm"""
+    """Tells the simulation if there is any point in continuing.
+    End of simulation defined as the event when the whole population is either
+    dead or completely recovered."""
     all_dead = all(not people.alive for people in pop)
     all_healed = all(not people.sick and not people.infected for people in pop)
     return not(all_dead or all_healed)
 
 
 def statistics(pop):
-    """Stellt eine Statistik zusammen, welche am Ende des Programms durchgeführt wird."""
+    """Informs the user of population statistics following the extermination of
+    either the population or the virus"""
     alive = 0
     dead = 0
     immune = 0
+    r0 = 0
+    c = 0
 
     ppl_count = -1
     for people in pop:
@@ -317,6 +372,10 @@
         else:
             dead += 1
             end_dist['Alive'][ppl_count] = 0
+        c+= people.counter
+
+    r0 = c/popsize
+    print(r0)
 
     return alive, dead, immune, end_dist
 
@@ -326,7 +385,7 @@
 screen = pygame.display.set_mode(size)
 population = []
 
-# Aufbauen der Population
+# Creating the population
 for i in range(popsize):
     is_isolated = False
     is_infected = False
@@ -334,19 +393,16 @@
     is_heavy = False
     is_superspread = False
     temp = randint(1, popsize)
-    if temp < isolation: 
-        is_isolated = True # Mit einer gewählten Wahrscheinlichkeit ist die Person isoliert.
+    if temp < isolation:
+        is_isolated = True
     if temp < infected:
-        is_infected = True # Mit einer gewählten Wahrscheinlichkeit ist die Person infiziert.
+        is_infected = True
     if temp < superspreader:
-        is_superspread = True  # Mit einer gewählten Wahrscheinlichkeit ist die Person superspreader.
-    new_person = Person(is_isolated, is_infected,is_immune,is_heavy,is_infected,is_superspread) #Erstellen eines Objekts Person mit den oben genannten Eigenschaften
+        is_superspread = True
+    new_person = Person(is_isolated, is_infected,is_immune,is_heavy,is_infected,is_superspread)
     end_dist['Age'][i] = new_person.age
-    new_person.ps = new_person.ps.move(new_person.left*10, new_person.top*10) # Setzen der Personen auf das Spielfeld
+    new_person.ps = new_person.ps.move(new_person.left*10, new_person.top*10)
     population.append(new_person)
-
-
-#Initialisierung der Arrays für die Speicherung der Ergebnisse der einzenen Zeitschritte
 days = np.ones(100)
 days[0] = 0
 people_infected = np.zeros(1000)
@@ -363,7 +419,7 @@
     if count == 12:
         day_counter += 1
 
-    #Hilfsvariablen für die Berechnung
+
     inf=0
     inf_2 = 0
     imm=0
@@ -373,8 +429,6 @@
     d2 = 0
     z2 = 0
     tested = 0
-
-    #Durchzählen der Population auf bestimmte Eigenschaften
     for people in population:
         if people.infected ==True:
             inf+=1
@@ -391,6 +445,9 @@
             d+= people.counter
         if people.tested:
             tested +=1
+        '''if people.finished and people.superspreader:
+            z2 +=1
+            d2+= people.counter'''
 
     if fin>0:
         r0_current[day_counter] = d/fin
@@ -407,8 +464,10 @@
     people_alive[day_counter]=1-dead/popsize
 
     if count == 12:
-        print("Tag: ",day_counter,".....","Isolationsaufruf: ",isolation_enabled,".....","r0: ",r0_current[day_counter],".....","aktuell Infizierte: ",people_infected[day_counter],".....","Dunkelziffer: ",darkfigure[day_counter],".....","aktuell Immune: ",people_immune[day_counter],".....","aktuell Verstorbene: ",people_dead[day_counter])
+        print("Tag: ",day_counter,".....","Isolationsaufruf: ",isolation_enabled,".....","r0: ",r0_current[day_counter],".....","aktuell Infizierte: ",people_infected[day_counter],".....","Dunkelziffer: ",darkfigure[day_counter],".....","aktuell Immune: ",people_immune[day_counter],".....","aktuell Verstorbene: ",people_dead[day_counter],".....",people_infected[day_counter]/people_infected[day_counter-1])
         count = 0
+    #time.sleep(0.9)
+    #Exit Key (right arrow)
 
     #Isolation ist während des Programms über die Pfeiltasten rechts und links steuerbar.
     for event in pygame.event.get():
@@ -452,6 +511,8 @@
             elif people.immune:
                 people.isolated = False
 
+
+
     screen.fill(white)
     for person in population:
         person.ps = person.ps.move(person.speed)
@@ -465,7 +526,7 @@
             else:
                 person.contact(friend)
         if count == 0:
-            person.new_step()
+            person.new_day()
         screen.blit(person.image, person.ps)
 
     pygame.display.flip()
@@ -502,3 +563,15 @@
 
     # Diagramm anzeigen:
     plt.show()
+
+
+    """plt.figure(figsize=(12,6))
+    plt.style.use('seaborn-darkgrid')
+    end_dist['Age'].value_counts().sort_index().plot(c='purple',marker='o',label='Population',markersize=10)
+    end_dist[end_dist['Alive']==1]['Age'].value_counts().sort_index().plot(c='blue',marker='o',label='Alive')
+    end_dist[end_dist['Alive']==0]['Age'].value_counts().sort_index().plot(c='red',marker='o',label='Deceased')
+    plt.legend()
+    plt.xlabel('Age')
+    plt.ylabel('Count')
+    plt.title('Result')
+    plt.show()"""
