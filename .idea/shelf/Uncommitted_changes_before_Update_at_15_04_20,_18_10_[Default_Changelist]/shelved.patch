Index: simulation.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\nProgram: Coronavirus Simulation\nAuthor: Nathan Verghis\nDate: March 18, 2020\nI created this program in light of the coronavirus epidemic. I was inspired by\nthe vast confusion people had surrounding the need for isolation. I felt that by\ncreating this program, it could better teach people about why isolation is so\nimportant in preventing the spread of a virus. Plans on expanding in the future\ncould involve creating a special member of the People class (compromised person)\nto show the effectiveness of herd immunity on protecting a member of the\npopulation who can't be relied on recovering from a disease on their own. I can\nalso expand the program to collect data from different iterations at different\nvalues of infected and isolation to then graph in Matlab to better depict the\neffect of isolation.\ntest\ndas ist einn Test für GitKRaaaaken\n\n\"\"\"\n\n#   === INIT ===\n\nimport sys\nimport pygame\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom pygame.locals import *\nfrom random import randint\nimport time\nimport numpy as np\nscale = 800 #Skalierung\nup = 1.2   #Bewegungsgeschwindigkeit der Personen\n\npopsize = scale\n\n\nend_dist = pd.DataFrame(columns=['Age','Alive'],index=range(popsize))\n\ndev_mode = True\nresult = True\n\nif dev_mode == True:\n\n    isolation = 0#100\n    infected = 2\n    infection_chance = 60#100\n    recovery = 8\n    heavy_case = 5#2\n    incubation_time = 6\n    superspreader = 10\n\nelse:\n    # Game Settings\n    print(\"Please enter an isolation constant (0-100):\")\n    isolation = float(input())\n\n    print(\"Please enter an starting infected population (0-100):\")\n    infected = int(input())\n\n    print(\"Please enter an infection chance (0-100):\")\n    infection_chance = int(input())\n\n    #print(\"Please enter a mortality rate (0-100):\")\n    #mortality = int(input())\n    #über Statistik eingeführt\n\n    print(\"Please enter a recovery rate (0-100):\")\n    recovery = int(input())\n\n    print(\"Please enter a chance of a heavy case (0-100):\")\n    heavy_case = int(input())\n\n\n#mortality = 2\n#recovery = 15\n\npygame.init()\npygame.display.set_caption(\"Coronavirus Infection Simulation\")\nsize = width, height = scale, scale\nspeed = [25, 0]\nwhite = 255, 255, 255\nday_counter = 0\ncount = 0\npop_dist = [[0,18.4],[20,18.4+24.6],[40,18.4+24.6+28.8],[60,18.4+24.6+28.8+21.7],[80,18.4+24.6+28.8+21.7+6.5]]\n#Altersverteilung in Deutschland nach (https://www.destatis.de/DE/Themen/Gesellschaft-Umwelt/Bevoelkerung/Bevoelkerungsstand/Tabellen/liste-altersgruppen.html)\n#erster Eintrag: Untergrenze Alter, zweiter Eintrag: kumulierter Anteil an Bevölkerung\nmort_rate = [[0,(0+0.2)/2],[20,0.2],[40,(0.4+1.3)/2],[60,(3.6+8)/2],[80,14.8]]\n#Sterblichkeitsrate über Alter nach (https://www.dw.com/de/coronavirus-endlich-umfassende-daten-aus-china/a-52421582)\n#Quelle: Chinese Center for Disease Control and Prevention\n#erster Eintrag: Untergrenze Alter, zweiter Eintrag: Sterblichkeitsrate angepasst an Altersverteilung\n\n# === DEF ===\n\n# Creating People object\nclass Person:\n    \"\"\"A single person in the game. Has attributes of being sick, isolated, and\n    alive. Meant to interact with another member of its population to create\n    the simulation.\"\"\"\n    def __init__(self, isolated, sick,immune,heavy,infected,superspread):\n        self.alive = True\n        self.immune = False\n        self.isolated = isolated\n        self.infected = infected\n        self.sick = sick\n        self.heavy = heavy\n        self.age = 0\n        self.mortality = 0\n        self.dead =False\n        self.superspread = superspread\n        if self.isolated:\n            self.speed = [0, 0]\n\n        if self.superspread:\n            self.speed = [randint(-100, 100) * 0.05, randint(-100, 100) * 0.05]\n        else:\n\n            self.speed = [randint(-100, 100) * 0.025, randint(-100, 100) * 0.025]\n        if sick:\n            self.image = pygame.image.load(\"red box 2.jpg\")\n        if immune:\n            self.image = pygame.image.load(\"green square 2.jpg\")\n        if infected:\n            self.image = pygame.image.load(\"rosa box.jpg\")\n        if superspread:\n            self.image = pygame.image.load(\"yellow box 2.jpg\")\n\n        else:\n            self.image = pygame.image.load(\"black box.jpg\")\n        self.ps = self.image.get_rect()\n        self.left = randint(1, scale/(10))\n        self.top = randint(1, scale/(10))\n        rand_age = randint(0,100)\n        for age_class in range(len(pop_dist)):\n            if rand_age < pop_dist[age_class][1]:\n                self.age = pop_dist[age_class][0] + randint(0,20)\n                break\n        for age_class in range(len(mort_rate)-1):\n            if self.age >= mort_rate[-1][0]:\n                self.mortality = mort_rate[-1][1]\n                break\n            elif self.age < mort_rate[age_class+1][0]:\n                self.mortality =  mort_rate[age_class][1]\n                break\n\n    def new_day(self):\n        \"\"\"The change from day to day for a sick person.\n        They can either recover or die\n        If dead then they have no more impact on the population\"\"\"\n        #if input() == i:\n        #    self.isolated = True\n\n        if self.isolated:\n            self.speed = [0, 0]\n        if self.superspread:\n            pass\n        elif not self.alive == 0:\n            self.speed = [randint(-100, 100) * 0.04*up, randint(-100, 100) * 0.04*up]\n\n        if self.infected:\n            if randint(1,100) < incubation_time:\n                self.infected = False\n                self.sick = True\n                self.alive = True\n\n                self.image = pygame.image.load(\"red box 2.jpg\")\n\n        if self.sick:\n\n            if randint(1, 100) < heavy_case:\n                self.isolated = True\n                self.superspread = False\n                self.speed = [0, 0]\n                self.alive = True\n                self.heavy = True\n                self.sick = True\n                self.image = pygame.image.load(\"red box 2.jpg\")\n            elif randint(1, 100) < recovery:\n                self.sick = False\n                self.immune = True\n                self.alive = True\n                self.speed = [randint(-100, 100) * 0.05, randint(-100, 100) * 0.05]\n                self.image = pygame.image.load(\"green square 2.jpg\")\n\n        if self.heavy:\n\n            if randint(1, 100) < self.mortality:\n                self.isolated = True\n                self.superspread = False\n                self.speed = [0, 0]\n                self.alive = False\n                self.heavy = False\n                self.immune = False\n                self.dead = True\n                self.sick = False\n                #self.immune = False\n                self.image = pygame.image.load(\"dark red 2.jpg\")\n            elif randint(1, 100) < recovery:\n                self.sick = False\n                self.immune = True\n                self.alive = True\n                self.speed = [randint(-100, 100) * 0.05, randint(-100, 100) * 0.05]\n                self.image = pygame.image.load(\"green square 2.jpg\")\n\n\n    def contact(self, other):\n        \"\"\"The event that two people come in contact with each other.\n        Handles the case where the infection spreads\n        Also handles the change in direction as they part ways\n        Isolated people dont come into contact so people pass through them\"\"\"\n        if self.ps.colliderect(other.ps) and not self.immune and not other.immune and not self.isolated and not other.isolated:\n            self.speed[0], self.speed[1] = \\\n                self.speed[0] * -1, self.speed[1] * -1\n            other.speed[0], other.speed[1] = \\\n                other.speed[0] * -1, other.speed[1] * -1\n            if self.sick and not other.sick:\n                if infection_chance > randint(0,100):\n                    other.infected = True\n                    other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.sick:\n                if infection_chance >  randint(0,100):\n                    self.infected = True\n                    self.image = pygame.image.load(\"rosa box.jpg\")\n\n            if self.infected and not other.sick:\n                if infection_chance > randint(0,100):\n                    other.infected = True\n                    other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.infected:\n                if infection_chance >  randint(0,100):\n                    self.infected = True\n                    self.image = pygame.image.load(\"rosa box.jpg\")\n        if self.ps.colliderect(other.ps) and not self.immune and not other.immune: # and not self.isolated and not other.isolated:\n            self.speed[0], self.speed[1] = \\\n                self.speed[0] * -1, self.speed[1] * -1\n            other.speed[0], other.speed[1] = \\\n                other.speed[0] * -1, other.speed[1] * -1\n            if self.sick and not other.sick:\n                if infection_chance/2 > randint(0,100):\n                    other.infected = True\n                    other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.sick:\n                if infection_chance/2 >  randint(0,100):\n                    self.infected = True\n                    self.image = pygame.image.load(\"rosa box.jpg\")\n\n            if self.infected and not other.sick:\n                if infection_chance/2 > randint(0,100):\n                    other.infected = True\n                    other.image = pygame.image.load(\"rosa box.jpg\")\n            elif not self.sick and other.infected:\n                if infection_chance/2 >  randint(0,100):\n                    self.infected = True\n                    self.image = pygame.image.load(\"rosa box.jpg\")\n\n\ndef sim_continue(pop):\n    \"\"\"Tells the simulation if there is any point in continuing.\n    End of simulation defined as the event when the whole population is either\n    dead or completely recovered.\"\"\"\n    all_dead = all(not people.alive for people in pop)\n    all_healed = all(not people.sick and not people.infected for people in pop)\n    return not(all_dead or all_healed)\n\n\ndef statistics(pop):\n    \"\"\"Informs the user of population statistics following the extermination of\n    either the population or the virus\"\"\"\n    alive = 0\n    dead = 0\n    immune = 0\n\n    ppl_count = -1\n    for people in pop:\n        ppl_count += 1\n        end_dist['Age'][ppl_count] = people.age\n        if people.immune:\n            immune+=1\n        if people.alive:\n            alive += 1\n            end_dist['Alive'][ppl_count] = 1\n        else:\n            dead += 1\n            end_dist['Alive'][ppl_count] = 0\n\n    return alive, dead, immune, end_dist\n\n\n# === PROGRAM ===\n\nscreen = pygame.display.set_mode(size)\npopulation = []\n\n# Creating the population\nfor i in range(popsize):\n    is_isolated = False\n    is_infected = False\n    is_immune = False\n    is_heavy = False\n    is_superspread = False\n    temp = randint(1, popsize)\n    if temp < isolation:\n        is_isolated = True\n    if temp < infected:\n        is_infected = True\n    if temp < superspreader:\n        is_superspread = True\n    new_person = Person(is_isolated, is_infected,is_immune,is_heavy,is_infected,is_superspread)\n    end_dist['Age'][i] = new_person.age\n    new_person.ps = new_person.ps.move(new_person.left*10, new_person.top*10)\n    population.append(new_person)\ndays = np.ones(100)\ndays[0] = 0\npeople_infected = np.zeros(1000)\npeople_immune = np.zeros(1000)\npeople_dead = np.zeros(1000)\npeople_alive = np.zeros(1000)\npeople_infected[0] = infected/popsize\n# Creating the Simulation\nwhile sim_continue(population):\n    count += 1\n    if count == 8:\n        day_counter += 1\n\n\n    inf=0\n    imm=0\n    dead=0\n    for people in population:\n        if people.infected ==True:\n            inf+=1\n        if people.sick == True:\n            inf+=1\n        if people.immune ==True:\n            imm +=1\n        if people.dead == True:\n            dead +=1\n    people_infected[day_counter]=inf/popsize\n    people_immune[day_counter]=imm/popsize\n    people_dead[day_counter]=dead/popsize\n    people_alive[day_counter]=1-dead/popsize\n    if count == 8:\n        print(day_counter,\".....\",people_infected[day_counter],\".....\",people_immune[day_counter],\".....\",people_dead[day_counter],\".....\",100*people_infected[day_counter]/people_infected[day_counter-1]-100)\n        count = 0\n    #time.sleep(0.001)\n    #Exit Key (right arrow)\n    for event in pygame.event.get():\n        if event.type == KEYDOWN and event.key == K_RIGHT:\n            sys.exit()\n\n    screen.fill(white)\n    for person in population:\n        person.ps = person.ps.move(person.speed)\n        if person.ps.left < 0 or person.ps.right > width:\n            person.speed[0] = person.speed[0] * -1\n        if person.ps.top < 0 or person.ps.bottom > height:\n            person.speed[1] = person.speed[1] * -1\n        for friend in population:\n            if person is friend:\n                pass\n            else:\n                person.contact(friend)\n        if count == 0:\n            person.new_day()\n        screen.blit(person.image, person.ps)\n\n    pygame.display.flip()\n\n\n\nprint(\"Days til completion: \", day_counter)\n\nalive, dead, immune, end_dist = statistics(population)\n#stats = statistics(population)\nprint(\"Alive: \", alive)\nprint(\"Dead: \", dead)\nprint(\"Immune: \",immune)\n\n\nif result == True:\n    # === AUSWERTUNG ===\n\n    plt.ylabel('Aktuell Infizierte')\n\n    # Einen x-y-Plot erstellen:\n    plt.plot(people_infected, 'b-')\n    plt.plot(people_immune, 'g-')\n    plt.plot(people_dead, 'r-')\n    plt.plot(people_alive, 'y-')\n\n    # Achsen-Bereiche manuell festlegen\n    # Syntax: plt.axis([xmin, xmax, ymin, ymax])\n    #plt.axis([0, 5, 0, 20])\n\n    # Ein gepunktetes Diagramm-Gitter einblenden:\n    plt.grid(True)\n\n    # Diagramm anzeigen:\n    plt.show()\n\n\n    \"\"\"plt.figure(figsize=(12,6))\n    plt.style.use('seaborn-darkgrid')\n    end_dist['Age'].value_counts().sort_index().plot(c='purple',marker='o',label='Population',markersize=10)\n    end_dist[end_dist['Alive']==1]['Age'].value_counts().sort_index().plot(c='blue',marker='o',label='Alive')\n    end_dist[end_dist['Alive']==0]['Age'].value_counts().sort_index().plot(c='red',marker='o',label='Deceased')\n    plt.legend()\n    plt.xlabel('Age')\n    plt.ylabel('Count')\n    plt.title('Result')\n    plt.show()\"\"\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- simulation.py	(revision b1319365ceee6f90a74586c6afbd8d4e79d43858)
+++ simulation.py	(date 1585245002024)
@@ -156,7 +156,7 @@
         elif not self.alive == 0:
             self.speed = [randint(-100, 100) * 0.04*up, randint(-100, 100) * 0.04*up]
 
-        if self.infected:
+        if self.infected: # need to check if infectet -> not infected logic
             if randint(1,100) < incubation_time:
                 self.infected = False
                 self.sick = True
